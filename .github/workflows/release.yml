name: Release

on:
  push:
    tags:
      - 'v*.*.*'
      - 'v*.*.*-test'

permissions:
  contents: write

jobs:
  build-windows:
    name: Build Windows
    runs-on: windows-latest
    strategy:
      matrix:
        variant: [full, light]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25.4'

    - name: Extract version from tag
      id: version
      shell: bash
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Set build variables
      id: vars
      shell: bash
      run: |
        if [ "${{ matrix.variant }}" == "light" ]; then
          echo "tags=-tags light" >> $GITHUB_OUTPUT
          echo "suffix=-light" >> $GITHUB_OUTPUT
          echo "display_name=Light" >> $GITHUB_OUTPUT
        else
          echo "tags=" >> $GITHUB_OUTPUT
          echo "suffix=" >> $GITHUB_OUTPUT
          echo "display_name=Full" >> $GITHUB_OUTPUT
        fi

    - name: Prepare icon resources
      shell: bash
      run: |
        mkdir -p internal/tray
        if [ -f winres/icon.ico ]; then
          cp winres/icon.ico internal/tray/icon.ico
          echo "Icon copied to internal/tray/"
        else
          echo "Warning: winres/icon.ico not found"
        fi

    - name: Update winres.json with version
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"

        # Convert version to 4-component format required by Windows resources
        # If version is 1.2.3, convert to 1.2.3.0
        # If version is 1.2.3.4, use as-is
        DOT_COUNT=$(echo "$VERSION" | tr -cd '.' | wc -c)
        if [ "$DOT_COUNT" -eq 2 ]; then
          VERSION_FULL="${VERSION}.0"
        elif [ "$DOT_COUNT" -eq 3 ]; then
          VERSION_FULL="${VERSION}"
        else
          echo "Error: Invalid version format '$VERSION'. Expected format: X.Y.Z or X.Y.Z.W"
          exit 1
        fi

        echo "Version: $VERSION"
        echo "Version (4-component): $VERSION_FULL"

        # Update winres.json with version info
        if [ -f winres/winres.json ]; then
          # Use jq to update all version fields
          cat winres/winres.json | \
          jq ".RT_MANIFEST[\"#1\"][\"0409\"].identity.version = \"$VERSION_FULL\" | \
              .RT_VERSION[\"#1\"][\"0000\"].fixed.file_version = \"$VERSION_FULL\" | \
              .RT_VERSION[\"#1\"][\"0000\"].fixed.product_version = \"$VERSION_FULL\" | \
              .RT_VERSION[\"#1\"][\"0000\"].info[\"0409\"].FileVersion = \"$VERSION\" | \
              .RT_VERSION[\"#1\"][\"0000\"].info[\"0409\"].ProductVersion = \"$VERSION\"" \
          > winres/winres.json.tmp
          mv winres/winres.json.tmp winres/winres.json

          echo "Updated winres.json with version $VERSION"
          echo "Version fields updated:"
          echo "  - Manifest version: $VERSION_FULL"
          echo "  - File version: $VERSION_FULL"
          echo "  - Product version: $VERSION_FULL"
          echo "  - Info FileVersion: $VERSION"
          echo "  - Info ProductVersion: $VERSION"
        else
          echo "Warning: winres/winres.json not found"
        fi

    - name: Install go-winres
      shell: bash
      run: |
        go install github.com/tc-hib/go-winres@latest
        echo "$HOME/go/bin" >> $GITHUB_PATH

    - name: Generate Windows resources
      shell: bash
      run: |
        if [ -f winres/winres.json ]; then
          mkdir -p cmd/steelclock
          $HOME/go/bin/go-winres make --out winres/rsrc
          cp winres/*.syso cmd/steelclock/
          echo "Windows resources generated with version ${{ steps.version.outputs.version }}"
        else
          echo "Warning: winres/winres.json not found, skipping resource generation"
        fi

    - name: Build Windows executable
      shell: bash
      run: |
        GOOS=windows GOARCH=amd64 go build ${{ steps.vars.outputs.tags }} -ldflags="-s -w -H windowsgui" -o steelclock.exe ./cmd/steelclock
        echo "Built steelclock.exe (${{ steps.vars.outputs.display_name }})"

    - name: Create release package
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        PACKAGE_NAME="steelclock-v${VERSION}${{ steps.vars.outputs.suffix }}-windows-amd64"

        # Create release directory
        mkdir -p release/$PACKAGE_NAME

        # Copy executable
        cp steelclock.exe release/$PACKAGE_NAME/

        # Copy profiles directory
        cp -r profiles release/$PACKAGE_NAME/

        # Copy README
        cp README.md release/$PACKAGE_NAME/

        # Copy LICENSE
        if [ -f LICENSE ]; then
          cp LICENSE release/$PACKAGE_NAME/
        fi

        # Copy ICON_SETUP.md if exists
        if [ -f ICON_SETUP.md ]; then
          cp ICON_SETUP.md release/$PACKAGE_NAME/
        fi

        # Create archive
        cd release
        7z a "${PACKAGE_NAME}.zip" "$PACKAGE_NAME"
        cd ..

        echo "Created release package: ${PACKAGE_NAME}.zip"
        ls -lh release/*.zip

    - name: Upload Windows artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-release${{ steps.vars.outputs.suffix }}
        path: release/*.zip

  build-linux:
    name: Build Linux
    runs-on: ubuntu-latest
    strategy:
      matrix:
        variant: [full, light]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25.4'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libayatana-appindicator3-dev libgtk-3-dev

    - name: Extract version from tag
      id: version
      shell: bash
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Set build variables
      id: vars
      shell: bash
      run: |
        if [ "${{ matrix.variant }}" == "light" ]; then
          echo "tags=-tags light" >> $GITHUB_OUTPUT
          echo "suffix=-light" >> $GITHUB_OUTPUT
          echo "display_name=Light" >> $GITHUB_OUTPUT
        else
          echo "tags=" >> $GITHUB_OUTPUT
          echo "suffix=" >> $GITHUB_OUTPUT
          echo "display_name=Full" >> $GITHUB_OUTPUT
        fi

    - name: Prepare icon resources
      shell: bash
      run: |
        mkdir -p internal/tray
        if [ -f winres/icon.ico ]; then
          cp winres/icon.ico internal/tray/icon.ico
          echo "Icon copied to internal/tray/"
        else
          echo "Warning: winres/icon.ico not found"
        fi

    - name: Build Linux executable
      shell: bash
      run: |
        GOOS=linux GOARCH=amd64 go build ${{ steps.vars.outputs.tags }} -ldflags="-s -w" -o steelclock ./cmd/steelclock
        echo "Built steelclock (${{ steps.vars.outputs.display_name }})"

    - name: Create release package
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        PACKAGE_NAME="steelclock-v${VERSION}${{ steps.vars.outputs.suffix }}-linux-amd64"

        # Create release directory
        mkdir -p release/$PACKAGE_NAME

        # Copy executable
        cp steelclock release/$PACKAGE_NAME/

        # Copy profiles directory
        cp -r profiles release/$PACKAGE_NAME/

        # Copy README
        cp README.md release/$PACKAGE_NAME/

        # Copy LICENSE
        if [ -f LICENSE ]; then
          cp LICENSE release/$PACKAGE_NAME/
        fi

        # Create archive
        cd release
        tar -czvf "${PACKAGE_NAME}.tar.gz" "$PACKAGE_NAME"
        cd ..

        echo "Created release package: ${PACKAGE_NAME}.tar.gz"
        ls -lh release/*.tar.gz

    - name: Upload Linux artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-release${{ steps.vars.outputs.suffix }}
        path: release/*.tar.gz

  release:
    name: Create Release
    needs: [build-windows, build-linux]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Extract version from tag
      id: version
      shell: bash
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Download Windows Full artifact
      uses: actions/download-artifact@v4
      with:
        name: windows-release
        path: release/

    - name: Download Windows Light artifact
      uses: actions/download-artifact@v4
      with:
        name: windows-release-light
        path: release/

    - name: Download Linux Full artifact
      uses: actions/download-artifact@v4
      with:
        name: linux-release
        path: release/

    - name: Download Linux Light artifact
      uses: actions/download-artifact@v4
      with:
        name: linux-release-light
        path: release/

    - name: List release files
      run: ls -lh release/

    - name: Generate release notes
      id: release_notes
      uses: actions/github-script@v7
      with:
        script: |
          const tag = '${{ steps.version.outputs.tag }}';
          const version = '${{ steps.version.outputs.version }}';

          // Get all tags
          const tags = await github.rest.repos.listTags({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });

          // Find previous tag
          const currentTagIndex = tags.data.findIndex(t => t.name === tag);
          const previousTag = currentTagIndex < tags.data.length - 1
            ? tags.data[currentTagIndex + 1].name
            : null;

          let releaseNotes = `## What's New in ${tag}\n\n`;

          // Platform notes with both variants
          releaseNotes += `### Downloads\n\n`;
          releaseNotes += `**Full Build** (all widgets):\n`;
          releaseNotes += `- Windows: \`steelclock-v${version}-windows-amd64.zip\`\n`;
          releaseNotes += `- Linux: \`steelclock-v${version}-linux-amd64.tar.gz\`\n\n`;
          releaseNotes += `**Light Build** (excludes telegram widgets):\n`;
          releaseNotes += `- Windows: \`steelclock-v${version}-light-windows-amd64.zip\`\n`;
          releaseNotes += `- Linux: \`steelclock-v${version}-light-linux-amd64.tar.gz\`\n\n`;

          releaseNotes += `> **Linux users**: For direct USB driver access, install the udev rules from \`profiles/99-steelseries.rules\`\n\n`;

          if (previousTag) {
            // Get commits between tags
            const comparison = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: previousTag,
              head: tag
            });

            releaseNotes += `### Changes since ${previousTag}\n\n`;

            // Group commits by type
            const features = [];
            const fixes = [];
            const other = [];

            comparison.data.commits.forEach(commit => {
              const msg = commit.commit.message.split('\n')[0];
              const lowerMsg = msg.toLowerCase();

              if (lowerMsg.startsWith('feat:') || lowerMsg.includes('feature')) {
                features.push(`- ${msg}`);
              } else if (lowerMsg.startsWith('fix:') || lowerMsg.includes('fixed')) {
                fixes.push(`- ${msg}`);
              } else {
                other.push(`- ${msg}`);
              }
            });

            if (features.length > 0) {
              releaseNotes += `#### Features\n${features.join('\n')}\n\n`;
            }
            if (fixes.length > 0) {
              releaseNotes += `#### Bug Fixes\n${fixes.join('\n')}\n\n`;
            }
            if (other.length > 0) {
              releaseNotes += `#### Other Changes\n${other.join('\n')}\n\n`;
            }

            releaseNotes += `\n**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${tag}`;
          } else {
            releaseNotes += 'Initial release\n';
          }

          return releaseNotes;
        result-encoding: string

    - name: Create GitHub Release Draft
      uses: softprops/action-gh-release@v2
      with:
        draft: true
        name: Release ${{ steps.version.outputs.tag }}
        body: ${{ steps.release_notes.outputs.result }}
        files: |
          release/*
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
